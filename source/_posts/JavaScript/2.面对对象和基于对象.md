---
title: 2.面对对象和基于对象
data: 2019-5-16
tags: JS
categories: JS基本语法
---


##### 面对对象和基于对象
1. c++:基于类(已经有人类的的概念，创建一个人)
1. js:基于原型( 基于对象:照猫画虎)

从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。

##### 对象的特征
- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。
- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。 
- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。

第一特征为内存地址

第二，三特征
1. c和java中卫属性和方法
2. js中状态和行为统一抽象为“属性”


##### JavaScript 对象的两类属性
**第一类属性，数据属性**
1. value：就是属性的值。
1. writable：决定属性能否被赋值。
1. enumerable：决定 for in 能否枚举该属性。
1. configurable：决定该属性能否被删除或者改变特征值.。

```
Object.getOwnPropertyDescriptor         //访问
Object.defineProperty                   //修改
Object.freeze(a)                        //冻结
var o = { a: 1 };
o.b = 2;
Object.defineProperty(o, "b", {value: 2, writable: false, enumerable: false, configurable: true});
console.log(Object.getOwnPropertyDescriptor(o,"a")) 
// {value: 1, writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(o,"b")) 
// {value: 2, writable: true, enumerable: true, configurable: true}
```

**第二类属性是访问器（getter/setter）属性**
1. getter：函数或 undefined，在取属性值时被调用。 
2. setter：函数或 undefined，在设置属性值时被调用。
3. enumerable：决定 for in 能否枚举该属性。
4. configurable：决定该属性能否被删除或者改变特征值。 

访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属时，得到完全不同的值，它可以视为一种函数的语法糖。


```
var a={
    _age:18
}

Object.defineProperty(a,"age",{
    get:function(){
        return this._age
    },
    set:function(age){
        if(age<0)
        {
            this.age=0
        }
    },
    enumerable:true         //默认为false
})
console.log(Object.getOwnPropertyDescriptor(a,"age")) 

//Object {get: , set: , enumerable: true, configurable: false}

```
